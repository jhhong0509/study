# 3.1.0 IPC의 종류

서비스에 적용 가능한 IPC 기술은 종류가 많다.

- HTTP 기반 Rest 통신
- gRPC
- AMQP
- STOMP

또한 메세지 포맷도 JSON, XML이나 Protocol Buffer와 같이 효율이 좋은 포맷까지 다양하다.

<br>

# 3.1.1 상호 작용 스타일

서비스 API에 맞는 IPC를 선택하기 전, **서비스와 클라이언트 사이의 상호작용 스타일**에 대해 이해하는게 좋다.

그래야지 IPC 기술의 세부 내용에 빠져 헤매는걸 방지할 수 있다.

상호 작용 스타일의 선택은 Application의 가용성에도 영향을 미치며, 테스트 전략 수립에도 좋다.

상호 작용 스타일은 두 가지 기준으로 분류할 수 있다.

<br>

먼저 요청을 처리하는 서비스의 개수이다.

- **일대일:** 각 클라이언트의 요청을 한 서비스가 처리
- **일대다:** 각 클라이언트의 요청을 여러 서비스가 처리

<br>

그리고 동기인지 비동기인지 여부를 선택하면 된다.

- **동기:** 클라이언트는 서비스가 즉시 응답하리라 기대하고 Thread를 Blocking한다.
- **비동기:** 클라이언트가 블로킹되지 않는다. 응답은 굳이 즉시 전송될 필요도 없다.

<br>

각각 스타일에 따른 종류는 다음과 같다.

| 서비스 | 일대일                            | 일대다                        |
| ------ | --------------------------------- | ----------------------------- |
| 동기   | Request/Response                  | X                             |
| 비동기 | 비동기 요청/응답<br />단방향 알림 | pub/sub<br />발행/비동기 응답 |

<br>

## 일대일 상호작용

### Request/Response

클라이언트는 서비스에 요청을 하고 응답을 기다린다.

클라이언트는 응답이 제때 도착하리라 기대하고, 대기 중 **블로킹**된다.

결국 **서비스가 강하게 결합**된다.

<br>

### Asynchronous Request/Response

클라이언트는 서비스에 요청을 보내고, 서비스는 **비동기적으로 응답**한다.

클라이언트는 **블로킹하지 않고 서비스는 응답을 오랫동안 하지 않을 수 있다.**

<br>

### One-way Notification

클라이언트는 일방적으로 요청만 하고, 서비스는 응답을 보내지 않는다.

Fire-And-Forget 모델과 비슷하다.

<br>

Synchronous Request/Response는 보통 **IPC 기술에 독립적**인 상호 작용 스타일 이다.

예를 들어, Request/Response Model로 REST 또는 Messaging 통신을 할 수 있다.

이 경우에는 Message Broker로 통신하고 있더라도 **Client는 Blocking**된다.

서비스가 느슨한 결합을 유지하고 있든, 강하게 결합되어 있든 Blocking된다.

> 이 부분은 뒤에서 다시 다룰 에정이다.

<br>

## 일대다 상호 작용

### Publisher/Subscribe

클라이언트는 **메세지를 발행**하고, 여기에 관심이 있는 서비스들이 **메세지를 소비**한다.

관심이 있는 서비스는 있을수도, 없을수도 있다.

<br>

### Publish/Async Response

클라이언트는 **메세지를 발행**하고, **주어진 시간 안에 서비스가 응답하길 기다린다.**

서비스의 응답을 기다린다는 점에서 Pub/Sub 모델과는 다르다.

<br>

# 3.1.2 마이크로서비스 API 정의

Application은 여러 모듈로 구성되며, 모듈마다 클라이언트가 호출할 작업이 정의된 인터페이스가 존재한다.

잘 설계되었다면 유용한 기능은 표출하되, 구현체는 감추어서 클라이언트에게 영향 없이 코드 수정이 가능하다.

<br>

Monolithic Application은 대부분 프로그래밍 언어에 맞게 인터페이스를 지정한다.

예를 들어 자바에선 클라이언트가 호출할 메소드들이 정해져 있고, 클라이언트는 구현체를 직접 바라볼 수 없다.

자바는 정적 타입 언어 이기 때문에 클라이언트와 인터페이스가 다르면 컴파일조차 되지 않는다.

<br>

MSA에서는 API와 인터페이스 모두 중요하다.

서비스 API는 **서비스와 클라이언트 간의 약속**으로, **호출 가능한 Operation과 이벤트**로 구성되어 있다.

Operation은 이름, 매개변수, 반환 타입으로 이루어져 있고, 이벤트는 타입과 필드를 가지고 메세지 채널에 발행되게 된다.

> 3.3절에서 더 자세하게 설명한다.

<br>

문제는 서비스 API가 **단순한 프로그래밍 언어의 일부분이 아니라는 점**이다.

규칙에 따르면 서비스와 클라이언트는 함께 컴파일되지 않는다.

따라서 새 버전의 서비스가 이전 버전과는 호환되지 않는 API를 배포하더라도, **컴파일 에러 없이 런타임에서 조용히 실패**할 것이다.

<br>

어떤 IPC를 선택하는 API를 IDL로 정확하게 정의해야 한다.

> IDL이란 Interface Definition Language로, 어느 언어에 국한되지 않는 방법으로 인터페이스를 표현하는 언어이다.
>
> 이를 통해서 인터페이스를 정의하고, Java와 같은 구현 언어로의 매핑을 지원한다.

API First 방식으로 서비스를 정의하는건 좋은 [자료](http://bit.ly/msp-7)들이 있다.

IDL을 작성한 후에 클라이언트 개발자와 몇번 의논한 후에 API를 정의하고, 서비스를 구현한다.

이렇게 먼저 설계를 하는 방법은 **클라이언트의 요구에 좀 더 부합한 서비스**를 구축할 수 있다.

<br>

API의 내용은 IPC에 의해 결정된다.

메세징으로 통신하는 API는 메세지 채널, 타입, 포맷으로 정의한다.

HTTP는 URL, HTTP Method, Response 포맷으로 구성된다.

<br>

# 3.1.3 API 발전

API는 새 기능을 추가하거나, 기존의 기능을 변경하는 등 **계속해서 변화한다.**

Monolithic Application에서는 API를 바꾸고, 메소드의 호출부를 수정하는게 어렵지 않다.

> 정적 타입 언어의 경우에는 컴파일 에러를 보면 쉽게 찾을 수 있다.

<br>

하지만 MSA에선 클라이언트를 다른 팀이 개발한 경우가 대부분이다.

따라서 서비스 API를 변경하는건 힘들고, 서비스를 사용하는 클라이언트들을 강제로 업그레이드 시킬수도 있다.

또한 유지보수를 할 때 **서버를 내리지 않기 때문에 순서대로 서비스를 업그레이드 하여 신/구 버전을 동시에 실행**해야 한다.

이러한 문제를 해결하기 위해선 전략을 잘 세워야 한다.

<br>

## 시맨틱 버저닝

Semantic Versioning Specification은 API Versioning에 대한 유용한 가이드 이다.

버전 번호를 사용하는 방법이 명시되어 있다.

원래는 소프트웨어 패키징의 Versioning 용도로 사용되었는데, 분산 시스템에서 API Versioning으로 사용할 수 있다.

명세에 따르면 MAJOR.MINOR.PATCH 세 파트로 구성하고 다음 규칙에 따라 증가시킨다.

- **MAJOR:** 하위 호환되지 않는 변경분을 API에 적용
- **MINOR:** 하위 호환되는 변경분을 API에 적용
- **PATCH:** 하위 호환되는 오류 수정

<br>

이런 버전 번호는 API에서 여러 방법으로 사용될 수 있다.

Rest라면 URL 경로에, 메세징이라면 메세지에 버전을 넣을수도 있다.

<br>

### MINOR 변경

변경을 하더라도 웬만하면 **하위 호환성을 보장**하는 방향으로 해야한다.

대부분 API에 뭔가 추가하는 변경은 하위 호환을 보장한다.

- 요청에 Optional attribute를 추가
- Response에 attribute 추가
- 새로운 연산 추가

만약 이러한 변경만 한다면 오래된 클라이언트들도 새로운 서비스에서 잘 작동할 것이다.

단, `내가 하는 일은 보수적으로, 다른 사람의 일은 관대하게 바라보라` 라는 견고함의 원칙(Robustness Principle)을 지켜야 한다.

**Request에서 뭔가 누락되어도 서비스는 기본값을 제공**해야 하고, 클라이언트에서 **원하는 Response보다 많은 Response가 와도 클라이언트는 이를 무시**해야 한다.

Request/Response를 사용한다면 간단히 해결된다.

<br>

### MAJOR 변경

경우에 따라서 **기존 버전과 호환되지 않는 변경**을 적용해야 할 때가 있다.

동시에 클라이언트를 강제로 업그레이드 할 수 있는게 아니기 때문에, 서비스는 **한동안 신버전과 구버전 모두 지원해야 한다.**

Rest API라면 `/v1`과 `/v2`와 같이 prefix를 붙여줘서 일시적으로 여러 API가 존재하게 하면 된다.

<br>

HTTP Content Negotiation을 통해 MIME타입 내부에 버전 번호를 끼워넣을 수도 있다.

``` http
GET /orders/xyz HTTP/1.1
Accept: application/vnd.example.resource+json; version=1
```

위와 같이 Accept 뒤에 version을 끼워서 넣을 수 있다.

위 헤더는 버전 1.X의 응답을 기대하고 있는 것이다.

<br>

여러 버전을 지원하려면 Service Adapter에서 신/구 버전을 올바르게 중계해 주어야 한다.

API Gateway는 거의 반드시 **Versioning된 API를 사용**하며, 심지어 구 버전 API를 여러개 지원해야 할수도 있다.

<br>

# 3.1.4 메세지 포맷

IPC의 핵심은 메세지의 교환이다.

대부분의 메세지는 데이터를 포함하고 있기 때문에 Data Format은 설계 단계에서 해야할 중요한 부분이다.

또 IPC의 효율, 사용성, 발전성에도 영향을 준다.

특히 Messaging이나 Http Protocol을 사용하려면 메세징 포맷을 결정해야 한다.

> gRPC와 같은 IPC는 이미 메세지 포맷이 결정되어 있다.

지금 단계에선 마이크로서비스를 무슨 언어로 작성할지 모르기 때문에 **Cross-Language 메세지 포맷**을 사용하는게 좋다.

오늘은 하나의 언어로 작성할지 몰라도 언젠가 다른 언어를 쓰게 될지 모르는 일 이다.

> 예를 들어 Java Serialization을 포맷으로 삼으면 안된다.

메세지 포맷은 크게 Text/Binary로 나눌 수 있다.

<br>

## Text-Based Message Format

먼저 JSON이나 XML같은 Text-Based 포맷이다.

이들의 장점은 **사람도 읽을 수 있다는 것**이다.

XML과 JSON message는 이름과 값으로 이루어진 메세지 포맷이다.

이러한 포맷은 **Client가 원하는 값만 뽑아서 가져갈 수 있도록 한다.**

> 만약 userId와 userName이 반환되어 왔을 때, Key가 userName인 것만 뽑아서 사용할 수 있다.

따라서 **이전 버전과의 호환성을 보장하기 간편하다.**

<br>

XML을 사용한다면 XML schema, JSON을 사용한다면 JSON schema를 사용하는것이 일반적이다.

> JSON schema는 메세지 속성의 이름/타입/Optional 여부가 정의되어 있다.

Text-Based Message Format의 단점은 **메세지가 길다**는 것이다.

모든 메세지의 Value 외에도 Key가 추가되어야 하고, 큰 메세지는 **파싱에서 오버헤드**도 존재한다.

따라서 효율이나 성능이 중요하다면 이진 포맷을 고려해 보아야 한다.

<br>

## Binary Message Formats

Binary Message Format은 여러 종류가 있지만, 주로 Protocol Buffer나 Avro가 사용된다.

둘 다 Typed IDL을 지원하며, **컴파일러가 메세지를 직렬화/역직렬화 하는 코드**를 생성한다.

따라서 서비스를 디자인할 때 API-First 방법을 사용해야 한다.

게다가 만약 Client를 정적 타입 언어로 작성하게 되면 클라이언트가 API를 올바르게 사용하고 있는지 컴파일러가 확인해 줄 수 있다.

<br>

하지만 Avro는 Schema를 알아야지 메세지를 해결할 수 있기 때문에 발전 측면에선 Protocol Buffer가 더 좋다.

> [Avro vs Thrift vs Protocol Buffer](https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html)

RPI의 작동 원리는 다음과 같다.

![img](../../images/113.jpeg)

> RMI는 IPC의 일종으로, RPC와 가장 큰 차이점은 **프로세스 프로그래밍이냐 객체 지향 프로그래밍이냐**로 나눌 수 있다.
>
> | 종류     | RPC                   | RMI                                    |
> | -------- | --------------------- | -------------------------------------- |
> | 지원     | Procedure Programming | Object-Oriented Programming            |
> | Param    | 기본적인 자료 구조    | 객체                                   |
> | 장점     |                       | RPC 장점 + 현대 프로그래밍 기법을 지원 |
> | 오버헤드 | 더 많음               | 적음                                   |
> | 파라미터 | 필수                  | 중요치 않음                            |
> | 러닝커브 | 높음                  | 낮음                                   |
>
> 자세한건 [RPC에 관한 설명](https://github.com/jhhong0509/study/blob/master/msa/03.rpc.md)에..



